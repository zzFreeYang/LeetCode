回溯的经典做法：
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表

我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。
回溯相关题目：
39.组合总和  40. 组合总和 II  46. 全排列  47. 全排列 II  78. 子集  90. 子集 II

举例:
全排列问题：78题   给你一个整数数组 nums ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。
下面这个图解画的很好:
https://leetcode-cn.com/problems/subsets/solution/shou-hua-tu-jie-zi-ji-hui-su-fa-xiang-jie-wei-yun-/

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        backtrack(list, new ArrayList<>(), nums, 0);
         return list;
    }

     void backtrack(List<List<Integer>> list , List<Integer> tempList, int []nums ,int start ){
        list.add(new ArrayList<>(tempList));
        for(int i = start ; i < nums.length ; i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, i + 1);
            tempList.remove(tempList.size() - 1);
        }
    }
}
概括分析，就是
第一步: 做出选择， 路径.add(选择)   对应代码就是    tempList.add(nums[i]);
第二步：如果后面还有可选路径，进行递归
第三步：到底了（在此题中表示 start = size = 3），回到上一级，撤销选择 路径.remove(选择) ，对应代码
 tempList.remove(tempList.size() - 1);

