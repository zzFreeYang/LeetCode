Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。

首先介绍 Monitor  和 lock  的概念:
    lock是一种数据类型,堆内存中它是对象逻辑区的头部分;每一个对象在jvm中都有lock（或者mutex）
    任何一个线程想要进入一个对象的实体，都需要拥有这个对象的锁（即在内存区中设置lock的标志位flag）
    其他的线程若果尝试去获得锁，就会进入等待状态，直到拥有锁的线程释放锁（即取消设置标志位）

    监管锁（Monitor Lock）
    我们知道每个对象都有一个唯一的monitor
    Monitor不同于Lock就是它还可以设置超时时间 类似于lock的语法糖
    管程（Monitor）使用锁（lock）确保了在任何情况下管程中只有一个活跃的线程，即确保线程互斥访问临界区

//====================================================================================================================

主要考察的是线程的生命周期:

    public enum State {
//尚未启动的线程的线程状态

        NEW,

//可运行线程的线程状态,
//     可运行线程状态正在Java虚拟机中执行，但它可能等待来自操作系统的其他资源如处理器。

        RUNNABLE,

//线程的线程状态被阻塞，等待监视器锁定(monitor lock),俗话说等待锁的释放

        BLOCKED,


//等待状态:可能是执行了下面三个方法的任意一个方法:
//1.Object的wait方法，并且没有使用timeout参数
//2.Thread的join方法，没有使用timeout参数
//3.LockSupport的park方法
// 处于等待状态的线程正在等待另一个线程执行特定操作: 比如调用了wait()后，等待调用notify()或者notifyAll()

        WAITING,


//具有指定等待时间的等待线程的线程状态。

        TIMED_WAITING,

//终止线程的线程状态。
//线程已完成执行。
        TERMINATED;

//======================================================================================================================

扩展一下:线程是什么?
线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等
但是会和进程内其他线程共享文件描述符、虚拟地址空间等。
Thread 的源码，会发现其基本操作逻辑大都是以 JNI 形式调用的本地代码。

线程实现的两个基本方法: 1. 扩展 Thread类 2 .实现 Runnable
将代码逻放在 Runnable 中，然后构建 Thread 并启动（start），等待结束（join）。
Runnable 的好处是，不会受 Java 不支持类多继承的限制

join()方法：谁调用这个方法，就让调用此方法的线程进入阻塞状态，等待我执行完毕之后，再往下执行。
wait()方法: 使进入WAITING状态
参考DEMO : A20201125.java


为什么要慎用ThreadLocal？
    Java 提供的一种保存线程私有信息的机制因为其在整个线程生命周期内有效，
    所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息
    通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。
    这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应 ThreadLocalMap！
    这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责 remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。













