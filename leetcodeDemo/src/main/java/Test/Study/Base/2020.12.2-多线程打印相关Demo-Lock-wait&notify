三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串
    对照Demo看思路:
方法1：使用Lock
     首先，State初始为0  三个线程start，他们会抢锁。无论谁抢到了，要看if是否满足才会打印，否则就会Unlock
     if满足的条件: 0%3 == 0 ,因此只有线程A可以进入if
     在if中，会将state++ , i++ ,然后打印.
     这样下一次就只会打印B

方法2：使用wait/notify
      线程A唤醒B，B唤醒C
      知识点:
      synchronized（lock）:当前线程执行这段同bai步代码块，必须获取lock的对象锁
      在代码块中执行lock.wait（）方法，该线程放弃lock对象锁（也就是lock维护的加锁计数器的值减1）(wait是一个Object的方法)
      wait()总是在一个循环中被调用，挂起当前线程来等待一个条件的成立。 Wait调用会一直等到其他线程调用notifyAll()时才返回。
      当一个线程在执行synchronized的方法内部，调用了wait()后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中(waiting queue),
        只要该线程在等待队列中， 就会一直处于阻塞状态，不会被调度执行。 要注意wait()方法会强迫线程先进行释放锁操作，所以在调用wait()时， 该线程必须已经获得锁，否则会抛出异常

为什么wait()一定要放在循环中?
如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能
条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断




